Prompt:
	denis@ubuntu:~$ == denis@ubuntu:/home/denis
	[username]@[name_of_system]:[current working directory of the shell]
	~: home directory /home/denis
	$: end of the prompt
Process command:
	program-name arguments
	ls -la Makefile: -> program-name: ls, arguments: -la Makefile
	ls -> (in dir of PATH - type env in shell)
	/bin/ls -> (in root dir), example /bin/ls or /snap/bin/code
	bin/foo -> relative pathname (in the PWD)
	./a.out -> (a.out in the PWD)

HOW SHELL EXECUTES PROGRAM?
	1. shell forks itself
	2. parent waits for child
	3. child exec's the command, passing the arguments

CHARACTERS WITH SPECIAL MEANING:
# ' " \ $ ` * ~ < > ( ) ! | & ; space newline

FILE DESCRIPTORS
stdin -> fd 0 (read)
stdout -> fd 1 (write)

REDIRECTION (redirect stdin and/or stdout)
	1. program forks itself
	2. child closes stdin and/or stdout
	3. child opens file(s)
	4. child exec's new program

	< file_path (close fd 0 and open file for reading)
	> file_path (close fd 1 and open file for writing)

	foo bar 35 <notes.txt >/dev/null
	1. shell forks itself
	2. parent waits for child
	3. child closes stdin, opens notes.txt for reading
	4. child closes stdin, opens /dev/null for writing
	5. child exec's the command, passing the arguments

	PIPELINING
	commandA | commandB
	- shell runs those commads parallel, it will redirect stdout of commandA
		as stdin for commandA

	ls -la bin | less
	1. shell creates pipe
	2. shell forks itself twice
	3. parent waits for both children
	4. one child redirects stdout to the pipe before it execs the first command
	5. other child redirects stdin to the pipe before it execs the second command

	pipeline: one command or multiple commands separated by |
	command-list: on or more pipelines seperated and terminated by ; & or newline

	ls -la ; cat notes.txt			!=			ls -la | cat notes.txt
		(with ;) shell executes first pipeline and waits to finish then executes the second pipeline.

RETURN VALUES
	every command return exit status
		0 = OK
		non-0 = error

pipelineA && pipelineB
	- if last command of A returns 0, then run B
pipelineA || pipelineB
	- if last command of A returns non-0, then run B

BUILT-IN COMMANDS
	- executed in the shell process
	- may be redirected/piped like a process command
	examples: help, cd, echo (print arguments to stdout),
		if, while, function, 

CONTROL FLOW CONSTRUCTS
	if command-list then command-list fi
	while command-list do command-list done

function foo {
	ls -la
	cd /
}

What happens with name collision between function names, built-in command names and process command names.
	1. function call
	2. built-in command
	3. process command (directories of PATH)

In shell true is 0, anything other is considered false.

function foo2 { cd $2; ls $1; }
foo2 /bin Desktop
echo $? (displays return value of last command)

BRACE EXPANSION
	preamble{comma-seperated-list}postscript

	foo{apple,banana}bar
	echo foo{apple,banana}bar
		-> fooapplebar foobananabar

echo ~

COMMAND SUBSTITUTION
	$(command) -> $(echo foo)
	`command` -> `echo foo`

ARITHMETIC SUBSTITUTION
	$((3 + 5))
	echo $((3 + 5))

FILENAME EXPANSION
	* (match any characters)
	? (match any single charachter)
		foo*bar: matches foo3bar, fooASDFASbar, foobar
		foo?bar: matches foo3bar

TERMINATE COMMAND WITH &
	ls -la &
	-> pipeline runs "in background"
	1. shell doesn't wait for the pipeline
	2. pipeline runs in a subshell
	3. the pipeline may not read the terminal
	4. the pipelon may (or may not) write to the terminal

(JOB CONTROL)
Session
	-> job: process, process
	-> job: process, process, process, process
	-> job: process, process, process, process, process, process

Commands:
jobs (list background jobs and their job numbers)
bg jobNumber (move job to the background)
fg jobNumber (move job to te foreground)

SHELL SCRIPTS (.sh)
	source file (executers commands from file in the current shell)
	source ~/.bashrc

	shebang
		#!/bin/bash
		#!/bin/python
		#!/bin/perl
	then we can run the file as executable... ./foo.sh
	chmo u+x foo.sh

Theory:
[1] https://www.youtube.com/playlist?list=PLFAC320731F539902&si=eJbj1f1oOu2oiChZ
